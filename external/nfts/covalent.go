package nfts

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"time"

	"rederinghub.io/utils/config"
)

type CovalentNfts struct {
	conf      *config.Config
	serverURL string
	apiKey    string
}

func NewCovalentNfts(conf *config.Config) *CovalentNfts {
	apiKey := conf.Covalent.Key
	serverURL := conf.Covalent.URL
	return &CovalentNfts{
		conf:   conf,
		apiKey: apiKey,
		serverURL: serverURL,
	}
}

func (c CovalentNfts) request(url string, method string, headers map[string]string, reqBody io.Reader) ([]byte, error) {
	// Generated by curl-to-Go: https://mholt.github.io/curl-to-go
	req, err := http.NewRequest(method, url, reqBody)
	if err != nil {
		return nil, err
	}
	req.SetBasicAuth(c.apiKey, "")
	req.Header.Set("Content-Type", "application/json")

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	return body, nil
} 

func (c CovalentNfts) GetNftTransactions(f CovalentNftTransactionFilter) (*CovalentGetNftTransactionResponse, error) {
	var chain string
	if f.Chain == nil {
		chain = c.conf.Covalent.Chain
	} else {
		chain = *f.Chain
	}
	chainID := ChainToChainID[chain]
	url := fmt.Sprintf("%s/%v/tokens/%s/nft_transactions/%s/?quote-currency=USD&format=JSON", c.serverURL, chainID, f.ContractAddress, f.TokenID);
	data, err := c.request(url, "GET", nil, nil)
	if err != nil {
		return nil, err
	}

	resp := &CovalentGetNftTransactionResponse{}
	err = json.Unmarshal(data, &resp)
	if  err != nil {
		return nil, err
	}
	return resp, nil
}

func (c CovalentNfts) GetTokenHolder(f CovalentGetTokenHolderRequest) (*CovalentGetTokenHolderResponse, error) {
	var chain string
	if f.Chain == nil {
		chain = c.conf.Covalent.Chain
	} else {
		chain = *f.Chain
	}
	chainID := ChainToChainID[chain]
	// make covalent api index from 1
	f.Page -= 1
	url := fmt.Sprintf("%s/%v/tokens/%s/token_holders/?quote-currency=USD&format=JSON&page-number=%v&page-size=%v", c.serverURL, chainID, f.ContractAddress, f.Page, f.Limit);
	data, err := c.request(url, "GET", nil, nil)
	if err != nil {
		return nil, err
	}

	resp := &CovalentGetTokenHolderResponse{}
	err = json.Unmarshal(data, &resp)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (c CovalentNfts) GetAllTokenHolder(f CovalentGetAllTokenHolderRequest) ([]CovalentGetTokenHolderResponse, error) {
	var chain string
	if f.Chain == nil {
		chain = c.conf.Covalent.Chain
	} else {
		chain = *f.Chain
	}
	chainID := ChainToChainID[chain]

	page := 0

	resps := make([]CovalentGetTokenHolderResponse, 0)

	for {
		url := fmt.Sprintf("%s/%v/tokens/%s/token_holders/?quote-currency=USD&format=JSON&page-number=%v&page-size=%v", c.serverURL, chainID, f.ContractAddress, page, f.Limit);
		data, err := c.request(url, "GET", nil, nil)
		if err != nil {
			return nil, err
		}

		resp := &CovalentGetTokenHolderResponse{}
		err = json.Unmarshal(data, &resp)
		if err != nil {
			return nil, err
		}
		resps = append(resps, *resp)
		if !resp.Data.Pagination.HasMore {
			break
		}
		page++
		time.Sleep(1 * time.Second)
	}
return resps, nil
}
